\section{Traduzione guidata dalla sintassi}

Associando attributi ai simboli grammaticali, si definiscono valori tramite regole semantiche. La traduzione guidata dalla sintassi costruisce un albero di parsing per calcolare questi valori.

\subsection{Definizioni guidate dalla sintassi (SSD)}

È una grammatica context-free con l'aggiunta di attributi e regole semantiche. Gli attributi sono associati ai simboli della grammatica, le regole semantiche sono associate alle produzioni.

\textbf{Osservazione:} Dato un simbolo della grammatica \(X\) e uno dei suoi attributi \(a\), si indica \(X.a\).

Una SSD che contiene solo attributi sintetizzati è detta \textbf{S-attribuita}. Ogni regola calcola un attributo associato alla variabile della parte sinistra della produzione mediante gli attributi associati ai simboli della parte destra. Una SSD senza effetti collaterali è detta \textbf{grammatica ad attributi}.

\subsection{Valutazione di una SSD ai nodi di un albero di parsing}

Un albero di parsing annotato mostra i valori degli attributi associati ai nodi.

Gli attributi ereditati sono utili quando la struttura dell'albero di parsing non corrisponde alla sintassi astratta del codice sorgente.

\subsubsection{Attributi sintetizzati}
Un attributo sintetizzato relativo ad un nodo \(N\) è definito unicamente in base ai figli di \(N\) e a \(N\) stesso.

\subsubsection{Attributi ereditati}
Un attributo ereditato relativo ad un nodo \(N\) è definito unicamente in base al padre di \(N\), a \(N\) stesso e ai fratelli di \(N\) (non dai figli).

\textbf{NB!} I terminali non possono avere attributi ereditati.

\subsection{Esempio: \(3 \times 5 \times 4\)}

\subsubsection{Prima grammatica}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to T * F\) \quad \(T.val = T.val \times F.val\)
    \item \(T \to F\) \quad \(T.val = F.val\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=2cm},
  level 3/.style={sibling distance=1.5cm}
]
\node {\(T.val =\)}
  child {node {\(T.val =\)}
    child {node {\(T.val\)}
      child {node {\(F.val\)}
        child {node {3}}
      }
    }
    child {node {*}}
    child {node {\(F.val\)}
      child {node {5}}
    }
  }
  child {node {*}}
  child {node {\(F.val\)}
    child {node {4}}
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, *, 5, *, 4

\subsubsection{Seconda grammatica (con attributi ereditati)}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to FT'\) \quad \(T'.inh = F.val\) \quad \(T.val = T'.syn\)
    \item \(T' \to *FT'_1\) \quad \(T'_1.inh = T'.inh \times F.val\) \quad \(T'.syn = T'_1.syn\)
    \item \(T' \to \varepsilon\) \quad \(T'.syn = T'.inh\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=2.2cm,
  level 1/.style={sibling distance=7cm},
  level 2/.style={sibling distance=4.5cm},
  level 3/.style={sibling distance=3.5cm},
  level 4/.style={sibling distance=2.5cm},
  every node/.style={align=center, text width=4.5cm, font=\small}
]
\node {\(T.val = T'.syn(60)\)}
  child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(3)\)}
    child {node[text width=1cm] {3}}
  }
  child {node[text width=4cm] {\(T'.inh = F.val(3)\) \\ \(T'.syn = T'_1.syn(60)\)}
    child {node[text width=1cm] {*}}
    child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(5)\)}
      child {node[text width=1cm] {5}}
    }
    child {node[text width=4.5cm] {\(T'_1.inh =\) \\ \(T'.inh \times F.val(15)\) \\ \(T'_1.syn = T'_2.syn(60)\)}
      child {node[text width=1cm] {*}}
      child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(4)\)}
        child {node[text width=1cm] {4}}
      }
      child {node[text width=4.5cm] {\(T'_2.inh =\) \\ \(T'_1.inh \times F.val(60)\) \\ \(T'_2.syn = T'_2.inh(60)\)}
        child {node[text width=1.5cm] {\(\varepsilon\)}}
      }
    }
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, 5, *, 4, \(\varepsilon\)

\textbf{Calcolo dei valori:}
\begin{itemize}
    \item \(F.val = 3\)
    \item \(T'.inh = 3\)
    \item \(F.val = 5\)
    \item \(T'_1.inh = 3 \times 5 = 15\)
    \item \(F.val = 4\)
    \item \(T'_2.inh = 15 \times 4 = 60\)
    \item \(T'_2.syn = 60\)
    \item \(T'_1.syn = 60\)
    \item \(T'.syn = 60\)
    \item \(T.val = 60\)
\end{itemize}



\subsection{Grafi delle dipendenze}

\subsubsection{Esempio: \(1 * 2\)}

\textbf{Produzioni e regole semantiche:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzione} & \textbf{Regole semantiche} \\
\hline
1) \(T \to FT'\) & \(T'.inh = F.val\) \\
 & \(T.val = T'.syn\) \\
\hline
2) \(T' \to * F T'_1\) & \(T'_1.inh = T'.inh \times F.val\) \\
 & \(T'.syn = T'_1.syn\) \\
\hline
3) \(T' \to \varepsilon\) & \(T'.syn = T'.inh\) \\
\hline
4) \(F \to \text{digit}\) & \(F.val = \text{digit}.lexval\) \\
\hline
\end{tabular}
\end{center}

\textbf{Grafo delle dipendenze:}

\begin{center}
\begin{tikzpicture}[
  node distance=1.5cm and 2cm,
  every node/.style={font=\footnotesize},
  arrow/.style={->, thick, >=stealth, dashed}
]

% Nodi disposti secondo l'immagine
\node (T9val) at (2,5) {\(T\) 9 \(val\)};
\node (F3val) at (-2,3.5) {\(F\) 3 \(val\)};
\node (inh5) at (2,3.5) {\(inh\) 5 \(T'\)};
\node (syn8) at (5,3.5) {8 \(syn\) \(T'\)};
\node (digit1) at (-2,2) {digit 1 \(lexval\)};
\node (star) at (0,2) {*};
\node (F4val) at (2,1.5) {\(F\) 4 \(val\)};
\node (inh6) at (4.5,1.5) {\(inh\) 6 \(T'\)};
\node (syn7) at (6.5,1.5) {7 \(syn\) \(T'\)};
\node (digit2) at (2,0) {digit 2 \(lexval\)};
\node (epsilon) at (4.5,0) {\(\varepsilon\)};

% Frecce come nell'immagine
% digit 1 -> F 3 val
\draw[arrow] (digit1) -- (F3val);

% F 3 val -> inh 5 T'
\draw[arrow] (F3val) to[out=0, in=180] (inh5);

% digit 2 -> F 4 val
\draw[arrow] (digit2) -- (F4val);

% F 4 val -> inh 6 T'
\draw[arrow] (F4val) -- (inh6);

% inh 5 T' -> inh 6 T' (curva)
\draw[arrow] (inh5) to[out=-20, in=150] (inh6);

% inh 6 T' -> syn 7 T' (arco sopra)
\draw[arrow] (inh6) to[out=60, in=120] (syn7);

% syn 7 T' -> syn 8 T'
\draw[arrow] (syn7) to[out=150, in=0] (syn8);

% syn 8 T' -> T 9 val (curva a destra)
\draw[arrow] (syn8) to[out=90, in=0] (T9val);

\end{tikzpicture}
\end{center}


\subsection{Ordinamento topologico}

Gli ordinamenti validi sono costituiti da sequenze \(N_1, N_2, \ldots, N_k\), tale che se esiste un arco dal nodo \(N_i\) al nodo \(N_j\) nel grafo delle dipendenze, allora deve essere \(i < j\).

\subsection{Grammatiche S-attribuite}

Una definizione guidata dalla sintassi è S-attribuita se e solo se ogni suo attributo è sintetizzato.

\subsection{Grammatiche L-attribuite}

Gli attributi associati ai simboli della parte destra di una regola, nel grafo delle dipendenze, possono avere archi orientati da sinistra a destra. Gli attributi ereditati possono utilizzare attributi ereditati o sintetizzati da sinistra e dalla stessa occorrenza, evitando cicli.

\subsubsection*{}
Non sempre le regole semantiche bastano, si inseriscono delle regole semantiche dette \textbf{effetti controllati}, che producono una traduzione corretta (stampe o interazione con la tavola dei simboli).
\subsubsection*{}
Permessi in modo che la traduzione per ogni ordinamento sia comunque corretta. I vincoli sono visti come archi impliciti.

\subsection{Alberi sintattici}

È utile trasformare una stringa in ingresso in un albero che ne rappresenta la struttura.

\subsection{Classi di SDT implementabili durante il parsing}

Due classi di SDT che consentono l'implementazione dell'SDT durante il parsing:

\begin{enumerate}
    \item La grammatica sottostante può essere riconosciuta da un parser LR e la SDD è S-attribuita (bottom-up)
    \item La grammatica sottostante può essere riconosciuta da un parser LL e la SDD è L-attribuita (top-down)
\end{enumerate}

\subsubsection{Marcatori e proprietà}

\textbf{Proprietà:} Se la grammatica arricchita con i marcatori può essere trattata da un dato metodo di parsing, allora lo SDT corrispondente può essere implementato durante il parsing.

\subsection{SDT postfissi}

Per una produzione \(A \to XYZ\) con azione alla fine.

\subsubsection{Schema di traduzione postfisso - Calcolatrice}

\textbf{Produzioni, Regole sintattiche e SDT:}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Produzioni} & \textbf{Regole sintattiche} & \textbf{SDT} \\
\hline
\(L \to E\) \textbf{n} & \{\texttt{print}(\(E.val\))\} & \{\texttt{print}(\(E.val\))\} \\
\hline
\(E \to E + T\) & \{\(E.val = E_1.val + T.val\)\} & \{\(E.val = E_1.val + T.val\)\} \\
\hline
\(E \to T\) & \{\(E.val = T.val\)\} & \{\(E.val = T.val\)\} \\
\hline
\(T \to T * F\) & \{\(T.val = T_1.val \times F.val\)\} & \{\(T.val = T_1.val \times F.val\)\} \\
\hline
\(T \to F\) & \{\(T.val = F.val\)\} & \{\(T.val = F.val\)\} \\
\hline
\(F \to (E)\) & \{\(F.val = E.val\)\} & \{\(F.val = E.val\)\} \\
\hline
\(F \to \textbf{digit}\) & \{\(F.val = \textbf{digit}.lexval\)\} & \{\(F.val = \textbf{digit}.lexval\)\} \\
\hline
\end{tabular}
\end{center}

\subsection{Stack del parser con attributi}

\textbf{Rappresentazione dello stack:}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
 & \(XYZ\) & \\
\hline
 & \(X.x\) \(Y.y\) \(Z.z\) & \\
\hline
\multicolumn{3}{c}{\(\uparrow\)} \\
\multicolumn{3}{c}{top} \\
\end{tabular}
\end{center}

Dopo una riduzione \(A \to XYZ\):

\begin{center}
\begin{tabular}{|c|}
\hline
\(A\) \\
\hline
\(A.a\) \\
\hline
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}

Dove \(A.a = f(X.x, Y.y, Z.z)\)

\subsection{Implementazione con manipolazione dello stack}

\textbf{Azioni con manipolazione esplicita dello stack:}

\begin{itemize}
    \item \(L \to E\) \textbf{n}: \{\texttt{print}(\(stack[top-1].val\)); \(top = top - 1\)\}
    \item \(E \to E + T\): \{\(E.val = E.val + T.val\)\}
    \item \(T \to T * F\): \{\(stack[top-2].val = stack[top-2].val \times stack[top].val\); \(top = top - 2\)\}
    \item \(F \to (E)\): \{\(stack[top-2].val = stack[top-1].val\); \(top = top - 2\)\}
\end{itemize}

\subsection{Esempio di parsing: \(3 * (5 + 2)\) \textbf{n}}

\textbf{Sequenza di parsing con lo stack:}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
& \(F\) & \(E\) & \(T\) & \(E+T\) & \(T*F\) & (\(E\)) & & \\
\hline
& \(\uparrow\) & & & & & & & \\
\hline
3 & * & ( & 5 & + & 2 & ) & \textbf{n} & \texttt{print} \\
\hline
\end{tabular}
\end{center}

\textbf{Evoluzione dello stack:}

\begin{itemize}
    \item Dopo applicazione di \(F \to (E)\): \(top\) viene decrementato
    \item Dopo riduzione: i valori vengono calcolati e memorizzati nella posizione corretta dello stack
\end{itemize}

\textbf{Posizioni dello stack durante il parsing:}

\begin{center}
\begin{tabular}{c}
top-2 \\
\(\uparrow\) \\
top-1 \\
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}





\subsection{Schemi di traduzione con azioni interne alle produzioni}

\subsubsection{Definizione e comportamento}

Un'azione può essere inserita in qualsiasi posizione nel corpo di una produzione. Essa sarà eseguita non appena tutti i simboli grammaticali alla sua sinistra saranno stati consumati.

Quindi, in una produzione del tipo \(B \to X \{a\} Y\), l'azione \(a\) è eseguita non appena abbiamo riconosciuto \(X\), se \(X\) è un terminale, oppure tutti i terminali derivati da \(X\), se quest'ultimo è un non-terminale.

\textbf{Comportamento nel parsing:}

\begin{itemize}
    \item Nel parsing \textbf{bottom-up}: si esegue l'azione \(a\) non appena l'occorrenza in esame del simbolo \(X\) appare sulla cima dello stack
    \item Nel parsing \textbf{top-down}: si esegue l'azione \(a\) immediatamente prima di tentare l'espansione di \(Y\), se \(Y\) è un non-terminale, oppure prima di cercare \(Y\) in ingresso, se \(Y\) è un terminale
\end{itemize}

\subsection{Eliminazione della ricorsione sinistra dagli SDT}

\subsubsection{Motivazione e principi}

Poiché nessuna grammatica che presenti ricorsione sinistra può essere analizzata mediante parsing top-down, diventa fondamentale eliminare tale tipo di ricorsione.

Quando una grammatica è L-attribuita e la si trasforma per eliminare la ricorsione sinistra, dobbiamo gestire correttamente le azioni semantiche.

\textbf{Assunzione:} Le azioni semantiche non calcolano valori di attributi ma effettuano azioni sulle stringhe di simboli terminali.

\textbf{Principio:} Nel processo di trasformazione della grammatica, le azioni semantiche sono trattate come ulteriori simboli terminali.

\subsubsection{Trasformazione standard}

Le trasformazioni della grammatica preservano l'ordine dei terminali nella stringa generata. La strategia consiste nel sostituire produzioni della forma:
\[
A \to A\alpha \mid \beta
\]
con nuove produzioni usando un nuovo non-terminale \(R\):
\[
A \to \beta R
\]
\[
R \to \alpha R \mid \varepsilon
\]

\subsubsection{Trasformazione per SDD S-attribuite}

Per una singola produzione ricorsiva, una singola produzione non-ricorsiva, ed un singolo attributo del non-terminale ricorsivo sinistro.

\textbf{Grammatica originale con ricorsione sinistra:}

\begin{itemize}
    \item \(A \to A\alpha\) con azione \(\{A.a = g(A_1.a, \alpha.y)\}\)
    \item \(A \to X\) con azione \(\{A.a = f(X.x)\}\)
\end{itemize}

\textbf{Grammatica trasformata senza ricorsione sinistra:}

\begin{itemize}
    \item \(A \to X\) \(\{R.i = f(X.x)\}\) \(R\) \(\{A.a = R.s\}\)
    \item \(R \to \alpha\) \(\{R_1.i = g(R.i, \alpha.y)\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
\end{itemize}

Dove \(R.i\) è l'attributo ereditato e \(R.s\) è l'attributo sintetizzato di \(R\).

\subsubsection{Esempio - Eliminazione ricorsione nelle espressioni}

\textbf{SDT con ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzioni} & \textbf{Azioni semantiche} \\
\hline
\(E \to E_1 + T\) & \(\{\text{print}('+');\}\) \\
\hline
\(E \to T\) & \\
\hline
\end{tabular}
\end{center}

\textbf{SDT senza ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzioni} & \textbf{Azioni semantiche} \\
\hline
\(E \to T R\) & \\
\hline
\(R \to + T\) \(\{\text{print}('+');\}\) \(R_1\) & \\
\hline
\(R \to \varepsilon\) & \\
\hline
\end{tabular}
\end{center}

\subsubsection{Esempio completo - Calcolatrice da tavolo}

\textbf{Con ricorsione sinistra:}

\begin{itemize}
    \item \(E \to E_1 + T\) \(\{E.v = E_1.v + T.v\}\)
    \item \(E \to T\) \(\{E.v = T.v\}\)
    \item \(T \to T_1 \times F\) \(\{T.v = T_1.v \times F.v\}\)
    \item \(T \to F\) \(\{T.v = F.v\}\)
    \item \(F \to (E)\) \(\{F.v = E.v\}\)
    \item \(F \to \textbf{digit}\) \(\{F.v = \textbf{digit}.\text{lexval}\}\)
\end{itemize}

\textbf{Senza ricorsione sinistra:}

\begin{itemize}
    \item \(E \to T\) \(\{R.i = T.v\}\) \(R\) \(\{E.v = R.s\}\)
    \item \(R \to + T\) \(\{R_1.i = R.i + T.v\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
    \item \(T \to F\) \(\{X.i = F.v\}\) \(X\) \(\{T.v = X.s\}\)
    \item \(X \to \times F\) \(\{X_1.i = X.i \times F.v\}\) \(X_1\) \(\{X.s = X_1.s\}\)
    \item \(X \to \varepsilon\) \(\{X.s = X.i\}\)
\end{itemize}

\subsection{Procedure generali per SDT}

\subsubsection{Procedura in tre passi}

\begin{enumerate}
    \item Si costruisce l'albero di parsing, ignorando le azioni semantiche
    \item Si esamina ogni nodo interno \(N\) con produzione associata. Si aggiungono nuovi nodi figli di \(N\) corrispondenti alle azioni, in modo che scorrendo tutti i figli di \(N\) da sinistra a destra si abbiano esattamente gli stessi simboli e le stesse azioni semantiche
    \item Si visita l'albero in preordine e non appena si incontra un nodo annotato con un'azione la si esegue
\end{enumerate}

\subsubsection{Esempio con albero di parsing}

Per l'espressione \(3 \times 5 + 4\), l'output in notazione prefissa è: \(+ (\times 3 \ 5) \ 4\)

Le azioni \(\{\text{print}('+');\}\) e \(\{\text{print}('*');\}\) vengono eseguite visitando l'albero in preordine, stampando gli operatori prima degli operandi.


L'albero rappresenta il parsing dell'espressione \(3 \times 5 + 4\) con le azioni di stampa in notazione prefissa.

\begin{center}
\begin{tikzpicture}[
  level distance=1.6cm,
  level 1/.style={sibling distance=5cm},
  level 2/.style={sibling distance=3.5cm},
  level 3/.style={sibling distance=2.8cm},
  level 4/.style={sibling distance=2cm},
  level 5/.style={sibling distance=1.5cm},
  every node/.style={align=center, font=\small},
  action/.style={fill=yellow!40, rectangle, rounded corners, inner sep=3pt, font=\footnotesize}
]

\node (L) {\(L\)}
  child {node (E1) {\(E\)}
    child {node (E2) {\(E\)}
      child {node (T1) {\(T\)}
        child {node (T2) {\(T\)}
          child {node (F1) {\(F\)}
            child {node (d1) {digit}
              child {node[action] (a3) {\{\text{print}(3);\}}}
            }
          }
        }
        child {node (star) {*}}
        child {node (F2) {\(F\)}
          child {node (d2) {digit}
            child {node[action] (a5) {\{\text{print}(5);\}}}
          }
        }
      }
      child {node (plus) {+}}
      child {node (T3) {\(T\)}
        child {node (F3) {\(F\)}
          child {node (d3) {digit}
            child {node[action] (a4) {\{\text{print}(4);\}}}
          }
        }
      }
    }
    child {node (n) {\textbf{n}}}
  };

% Azioni semantiche con linee tratteggiate
\node[action, left=2cm of E2] (print_plus) {\{\text{print}('+');\}};
\node[action, left=2cm of T2] (print_star) {\{\text{print}('*');\}};

% Linee tratteggiate che collegano le azioni ai nodi
\draw[dashed, gray, thick] (print_plus) -- (E2);
\draw[dashed, gray, thick] (print_star) -- (T1);

\end{tikzpicture}
\end{center}

\textbf{Output in notazione prefissa:} + * 3 5 4

\textbf{Ordine di esecuzione delle azioni:}
\begin{enumerate}
    \item print('+')
    \item print('*')
    \item print(3)
    \item print(5)
    \item print(4)
\end{enumerate}
